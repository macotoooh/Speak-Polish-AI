"use client";

import { useRef, useState } from "react";
import Player from "@/components/Player";
import Recorder from "@/components/Recorder";
import type { PronunciationFeedback } from "@/types/pronunciation";
import type { TextFeedbackResponse } from "@/types/text-feedback";

type SelectionRange = {
  start: number;
  end: number;
};

type TextFeedbackResult = TextFeedbackResponse & {
  range: SelectionRange;
};

export default function Home() {
  const [text, setText] = useState("The weather in Vancouver is often rainy.");
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);
  const [selectionRange, setSelectionRange] = useState<SelectionRange | null>(
    null,
  );
  const [selectedText, setSelectedText] = useState("");
  const [textFeedback, setTextFeedback] = useState<TextFeedbackResult | null>(
    null,
  );
  const [isTextAnalyzing, setIsTextAnalyzing] = useState(false);
  const [textFeedbackError, setTextFeedbackError] = useState<string | null>(
    null,
  );
  const [spokenText, setSpokenText] = useState("");
  const [aiFeedback, setAiFeedback] = useState<PronunciationFeedback | null>(
    null,
  );
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [feedbackError, setFeedbackError] = useState<string | null>(null);

  const analyzePronunciationFromAudio = async (
    targetText: string,
    audioBlob: Blob,
  ) => {
    setIsAnalyzing(true);
    setFeedbackError(null);
    setAiFeedback(null);
    setSpokenText("");

    try {
      const formData = new FormData();
      formData.append("targetText", targetText);
      formData.append("audio", audioBlob, "recording.webm");

      const response = await fetch("/api/pronunciation-feedback", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        const errorPayload = (await response.json().catch(() => null)) as {
          error?: string;
          detail?: string;
        } | null;
        const detailMessage = errorPayload?.detail
          ? ` (${errorPayload.detail})`
          : "";
        throw new Error(
          `${errorPayload?.error ?? "Failed to analyze pronunciation."}${detailMessage}`,
        );
      }

      const result = (await response.json()) as PronunciationFeedback;
      setAiFeedback(result);
      setSpokenText(result.transcribedText);
    } catch (error) {
      const message =
        error instanceof Error
          ? error.message
          : "Failed to analyze pronunciation.";
      setFeedbackError(message);
    } finally {
      setIsAnalyzing(false);
    }
  };

  const handleRecordedAudio = (audioBlob: Blob) => {
    void analyzePronunciationFromAudio(text, audioBlob);
  };

  const updateSelectionState = () => {
    const textarea = textareaRef.current;
    if (!textarea) {
      return;
    }

    const start = textarea.selectionStart ?? 0;
    const end = textarea.selectionEnd ?? 0;

    if (start === end) {
      setSelectionRange(null);
      setSelectedText("");
      setTextFeedback(null);
      return;
    }

    setSelectionRange({ start, end });
    setSelectedText(text.slice(start, end));
    setTextFeedback(null);
    setTextFeedbackError(null);
  };

  const analyzeSelectedText = async () => {
    if (!selectionRange) {
      setTextFeedbackError("Please select text in the textarea first.");
      return;
    }

    const currentSelectedText = text.slice(selectionRange.start, selectionRange.end);
    if (currentSelectedText.trim().length === 0) {
      setTextFeedbackError("Please select non-empty text.");
      return;
    }

    setIsTextAnalyzing(true);
    setTextFeedbackError(null);
    setTextFeedback(null);

    try {
      const response = await fetch("/api/text-feedback", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          fullText: text,
          selectedText: currentSelectedText,
        }),
      });

      if (!response.ok) {
        const errorPayload = (await response.json().catch(() => null)) as {
          error?: string;
          detail?: string;
        } | null;
        const detailMessage = errorPayload?.detail
          ? ` (${errorPayload.detail})`
          : "";
        throw new Error(
          `${errorPayload?.error ?? "Failed to analyze selected text."}${detailMessage}`,
        );
      }

      const result = (await response.json()) as TextFeedbackResponse;
      setTextFeedback({
        ...result,
        selectedText: currentSelectedText,
        range: selectionRange,
      });
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "Failed to analyze selected text.";
      setTextFeedbackError(message);
    } finally {
      setIsTextAnalyzing(false);
    }
  };

  const applySuggestion = (suggestion: string) => {
    if (!textFeedback) {
      return;
    }

    const { start, end } = textFeedback.range;
    const currentSelectedText = text.slice(start, end);

    if (currentSelectedText !== textFeedback.selectedText) {
      setTextFeedbackError(
        "The text changed after analysis. Please select and analyze again.",
      );
      return;
    }

    const nextText = `${text.slice(0, start)}${suggestion}${text.slice(end)}`;
    setText(nextText);
    setSelectionRange(null);
    setSelectedText("");
    setTextFeedback(null);
    setTextFeedbackError(null);

    const textarea = textareaRef.current;
    if (!textarea) {
      return;
    }

    const nextSelectionEnd = start + suggestion.length;
    textarea.focus();
    textarea.setSelectionRange(start, nextSelectionEnd);
  };

  return (
    <main className="flex min-h-screen flex-col items-center justify-center gap-6 p-6">
      <h1 className="text-3xl font-bold">Speak & Improve AI üéôÔ∏è</h1>

      <div className="w-full max-w-md space-y-2">
        <textarea
          ref={textareaRef}
          className="border p-3 rounded w-full"
          value={text}
          onChange={(e) => {
            setText(e.target.value);
            setTextFeedback(null);
            setTextFeedbackError(null);
          }}
          onSelect={updateSelectionState}
          name="targetText"
          rows={4}
        />
        <div className="flex items-center justify-between gap-2">
          <p className="text-sm text-gray-600">
            {selectedText ? `Selected: "${selectedText}"` : "Select text to analyze"}
          </p>
          <button
            type="button"
            onClick={() => void analyzeSelectedText()}
            disabled={!selectionRange || isTextAnalyzing}
            className="rounded-md bg-gray-800 px-3 py-2 text-sm text-white disabled:opacity-50"
          >
            {isTextAnalyzing ? "Analyzing..." : "Analyze text"}
          </button>
        </div>
      </div>

      <Player text={text} />

      <Recorder onRecorded={handleRecordedAudio} disabled={isAnalyzing} />

      {(isTextAnalyzing || textFeedback || textFeedbackError) && (
        <section className="w-full max-w-2xl rounded-lg border p-4">
          <h2 className="text-lg font-semibold">Text Grammar Feedback</h2>

          {isTextAnalyzing && (
            <p className="mt-2 text-gray-600">Analyzing selected text...</p>
          )}

          {textFeedbackError && (
            <p className="mt-2 text-red-600">{textFeedbackError}</p>
          )}

          {textFeedback && (
            <div className="mt-3 space-y-3">
              <p>
                <strong>Selected text:</strong> {textFeedback.selectedText}
              </p>
              <p>{textFeedback.explanation}</p>
              {textFeedback.suggestions.length > 0 && (
                <div className="space-y-2">
                  <p className="font-medium">Suggestions</p>
                  {textFeedback.suggestions.map((suggestion, index) => (
                    <div
                      key={`${suggestion}-${index}`}
                      className="rounded border p-2 space-y-2"
                    >
                      <p>{suggestion}</p>
                      <button
                        type="button"
                        className="rounded bg-blue-600 px-3 py-1 text-sm text-white"
                        onClick={() => applySuggestion(suggestion)}
                      >
                        Apply this suggestion
                      </button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </section>
      )}

      {spokenText && (
        <p className="text-gray-700">
          <strong>You said:</strong> {spokenText}
        </p>
      )}

      {(isAnalyzing || aiFeedback || feedbackError) && (
        <section className="w-full max-w-2xl rounded-lg border p-4">
          <h2 className="text-lg font-semibold">AI Pronunciation Feedback</h2>

          {isAnalyzing && (
            <p className="mt-2 text-gray-600">Analyzing your speech...</p>
          )}

          {feedbackError && (
            <p className="mt-2 text-red-600">{feedbackError}</p>
          )}

          {aiFeedback && (
            <div className="mt-3 space-y-3">
              <p>
                <strong>AI Score:</strong> {aiFeedback.overallScore}/100
              </p>
              <p className="text-sm text-gray-500">
                Score basis: AI overall score from audio analysis.
              </p>
              <p>
                <strong>Evaluated sentence:</strong> {aiFeedback.targetText}
              </p>
              <p>{aiFeedback.summary}</p>
              <div className="space-y-1">
                <p>
                  <strong>Consonants:</strong> {aiFeedback.consonantComment}
                </p>
                <p>
                  <strong>Vowels:</strong> {aiFeedback.vowelComment}
                </p>
                <p>
                  <strong>Stress:</strong> {aiFeedback.stressComment}
                </p>
              </div>

              {aiFeedback.pronunciationIssues.length > 0 && (
                <div>
                  <p className="font-medium">Pronunciation Issues</p>
                  <ul className="list-disc pl-5">
                    {aiFeedback.pronunciationIssues.map((issue, index) => (
                      <li key={`${issue.expected}-${index}`}>
                        expected: <strong>{issue.expected}</strong> / heard:{" "}
                        <strong>{issue.heard}</strong> / tip: {issue.advice}
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {aiFeedback.practiceTips.length > 0 && (
                <div>
                  <p className="font-medium">How to Improve</p>
                  <ul className="list-disc pl-5">
                    {aiFeedback.practiceTips.map((tip, index) => (
                      <li key={`${tip}-${index}`}>{tip}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </section>
      )}
    </main>
  );
}
